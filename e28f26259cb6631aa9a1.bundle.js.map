{"version":3,"file":"e28f26259cb6631aa9a1.bundle.js","mappings":"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","sources":["webpack://multiple-choice-quiz/./src/quizworker.ts","webpack://multiple-choice-quiz/./src/utils/Debouncer.ts"],"sourcesContent":["import { Question } from \"./Question\";\nimport { State } from \"./State\";\nimport { Debouncer } from \"./utils/Debouncer\";\n\ninterface AnsweredQuestion { id: number, correct: number, total: number }\n\nlet currentQuiz: Question[];\nlet answeredQuestions: AnsweredQuestion[];\nlet currentAccessToken: string = null;\nlet currentSheetId: string = null;\nlet currentQuizId: string = null;\nlet repeat = 0;\nlet state: State = {\n    loading: true,\n    question: null,\n    needKey: false,\n    done: false,\n    decryptFailed: false,\n    reveal: false,\n    unsaved: false,\n    saveerror: false\n};\n\nfunction shuffle<T>(array: T[]): T[] {\n    let currentIndex: number = array.length;\n    let temporaryValue, randomIndex;\n    while (0 !== currentIndex) {\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n    }\n    return array;\n}\n\nasync function stateChange(c: (s: State) => State) {\n    state = c(state);\n    self.postMessage(state);\n}\n\nfunction nextQuestion() {\n    let question = currentQuiz.shift();\n    stateChange(s => {\n        return {\n            ...s, question: question,\n            loading: false,\n            needKey: false,\n            done: currentQuiz.length < 1,\n            reveal: false\n        };\n    });\n}\n\nasync function initialize(access_token: string, spreadsheetId: string, quizfile: string, quizSettings: { numberOfQuestions: number, repeat: number }, decryptionKey?: string) {\n    stateChange(s => {\n        return {\n            ...s,\n            needKey: false,\n            loading: true,\n            done: false,\n            question: null,\n            decryptFailed: false,\n            reveal: false,\n            unsaved: false,\n            saveerror: false\n        };\n    });\n    let saveKey: boolean = !!decryptionKey;\n    if (!decryptionKey) {\n        decryptionKey = await getDecryptionKey(access_token, spreadsheetId, quizfile);\n    }\n    if (!decryptionKey) {\n        stateChange(s => { return { ...s, needKey: true, loading: false }; });\n        return;\n    }\n    let [progress, quiz] = await Promise.all([getQuizProgress(access_token, spreadsheetId, quizfile), getQuiz(quizfile, decryptionKey)]);\n    for (let q of quiz) {\n        let p = progress.get(q.id);\n        if (p) {\n            q.total = p.total;\n            q.correct = p.correct;\n        }\n    }\n    if (saveKey) {\n        let res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(\"base!A1:B1\")}:append?valueInputOption=RAW`, {\n            headers: {\n                \"Authorization\": `Bearer ${access_token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ majorDimension: \"ROWS\", values: [[quizfile, decryptionKey]] })\n        });\n    }\n    currentQuiz = shuffle(quiz);\n    answeredQuestions = [];\n    currentQuiz = currentQuiz.sort((a, b) => {\n        if (a.correct != b.correct) {\n            return a.correct - b.correct;\n        }\n        return a.total - b.total;\n    });\n    if (quizSettings.numberOfQuestions < 1 || quizSettings.numberOfQuestions > currentQuiz.length) {\n        quizSettings.numberOfQuestions = currentQuiz.length;\n    }\n    if (quizSettings.repeat < 0) {\n        quizSettings.repeat == 0;\n    }\n    currentQuiz = currentQuiz.slice(0, quizSettings.numberOfQuestions);\n    repeat = quizSettings.repeat;\n    nextQuestion();\n    currentAccessToken = access_token;\n    currentSheetId = spreadsheetId;\n    currentQuizId = quizfile;\n}\n\nasync function getDecryptionKey(access_token: string, spreadsheetId: string, quizfile: string) {\n    let res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(\"base!A:B\")}`, {\n        headers: {\n            \"Authorization\": `Bearer ${access_token}`\n        }\n    });\n    let data: { values: [string, string][] } = await res.json();\n    if (!data.values) {\n        return null;\n    }\n    let key = data.values.find(d => d[0] == quizfile);\n    if (key) {\n        return key[1];\n    }\n    return null;\n}\n\nasync function getQuizProgress(access_token: string, spreadsheetId: string, quizfile: string) {\n    let res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(`${quizfile}!A:B`)}`, {\n        headers: {\n            \"Authorization\": `Bearer ${access_token}`\n        }\n    });\n    if (res.status == 400) {\n        let res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`, {\n            headers: {\n                \"Authorization\": `Bearer ${access_token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({\n                \"requests\": [{\n                    \"addSheet\": {\n                        \"properties\": {\n                            \"title\": quizfile\n                        }\n                    }\n                }]\n            })\n        });\n    }\n    let data: { values: [string, string][] } = await res.json();\n    let map = new Map<number, { correct: number, total: number }>();\n    if (null != data.values) {\n        for (let i = 0; i < data.values.length; i++) {\n            let correct = parseInt(data.values[i][0]);\n            let total = parseInt(data.values[i][1]);\n            if (!isNaN(correct) && !isNaN(total)) {\n                map.set(i + 1, { correct: correct, total: total });\n            }\n        }\n    }\n    return map;\n\n}\n\nasync function* loadAndDecryptQuiz(quizfile: string, decryptionKey: string) {\n    let res = await fetch(`quizzes/${quizfile}`);\n    let blob = await res.blob();\n    const salt = new Uint8Array([18, 182, 224, 94, 67, 153, 88, 240, 68, 90, 143, 209, 190, 39, 25, 237]);\n    let arrayBuffer = await blob.arrayBuffer();\n    let iv = new Uint8Array(arrayBuffer, 0, 12);\n    let cryptext = new Uint8Array(arrayBuffer, 12);\n    let encoder = new TextEncoder();\n    let keyMaterial = await self.crypto.subtle.importKey(\n        \"raw\",\n        encoder.encode(decryptionKey),\n        \"PBKDF2\",\n        false,\n        [\"deriveBits\", \"deriveKey\"]\n    );\n    let key = await self.crypto.subtle.deriveKey(\n        {\n            \"name\": \"PBKDF2\",\n            salt: salt,\n            \"iterations\": 100000,\n            \"hash\": \"SHA-256\"\n        },\n        keyMaterial,\n        { \"name\": \"AES-GCM\", \"length\": 256 },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n    try {\n        let decrypted = await self.crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: iv\n            },\n            key,\n            cryptext\n        );\n        let decoder = new TextDecoder(\"utf8\");\n        let question: Question = null;\n        for (let line of decoder.decode(decrypted).split(\"\\n\")) {\n            if (line.startsWith(\"#\")) {\n                if (null != question) {\n                    yield question;\n                }\n                question = {\n                    text: null,\n                    answers: [],\n                    id: parseInt(line.substr(1)),\n                    correct: 0,\n                    total: 0,\n                    repeat: 0\n                };\n            }\n            else if (question != null && question.text == null) {\n                question.text = line;\n            }\n            else if (/^(F|T)\\:/.test(line)) {\n                if (question == null) {\n                    throw \"no question\";\n                }\n                let correct = false;\n                if (line.startsWith(\"T\")) {\n                    correct = true;\n                }\n                question.answers.push({\n                    text: line.replace(/^(F|T)\\:/, \"\"),\n                    correct: correct\n                });\n            }\n        }\n        if (null != question) {\n            yield question;\n        }\n    }\n    catch (err) {\n        stateChange(s => { return { ...s, needKey: true, decryptFailed: true, loading: false }; });\n        throw err;\n    }\n}\n\nasync function getQuiz(quizfile: string, decryptionKey: string) {\n    const quiz: Question[] = [];\n    for await (const i of loadAndDecryptQuiz(quizfile, decryptionKey)) {\n        quiz.push(i);\n    }\n    return quiz;\n}\n\nlet debouncer = new Debouncer();\nlet lastSync = 0;\n\nasync function save(userAnswers: boolean[]) {\n    let iscorrect = !state.question.answers.map((a, idx) => userAnswers[idx] == a.correct).some(v => !v);\n    state.question.correct = iscorrect ? state.question.correct + 1 : state.question.correct;\n    state.question.total += 1;\n    if (state.question.repeat < repeat) {\n        state.question.repeat += 1;\n        currentQuiz.push(state.question);\n    }\n    stateChange(s => { return { ...s, reveal: true, unsaved: true, done: currentQuiz.length < 1 }; });\n    answeredQuestions.push({ id: state.question.id, correct: state.question.correct, total: state.question.total });\n    try {\n        await debouncer.trigger(Math.max(5000, 30000 - (+new Date() - lastSync)));\n    }\n    catch {\n        return;\n    }\n    let proc = Array.from(answeredQuestions);\n    answeredQuestions = [];\n    let updates: AnsweredQuestion[] = [];\n    for (let q of proc) {\n        if (!proc.find(q2 => q.id == q2.id && q2.total > q.total)) {\n            updates.push(q);\n        }\n    }\n    let res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${currentSheetId}/values:batchUpdate`, {\n        headers: {\n            \"Authorization\": `Bearer ${currentAccessToken}`,\n            \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\",\n        body: JSON.stringify({\n            valueInputOption: \"RAW\",\n            data: updates.map(q => {\n                return {\n                    range: `${currentQuizId}!A${q.id}:B${q.id}`,\n                    \"majorDimension\": \"ROWS\",\n                    \"values\": [\n                        [q.correct, q.total]\n                    ]\n                };\n            })\n        })\n    });\n    if (res.ok) {\n        stateChange(s => { return { ...s, unsaved: false, saveerror: false }; });\n    } else {\n        for (let q of updates) {\n            answeredQuestions.push(q);\n        }\n        stateChange(s => { return { ...s, saverror: true }; });\n    }\n    lastSync = +new Date();\n}\n\nself.addEventListener(\"message\", ev => {\n    if (ev.data.type == \"load\") {\n        initialize(ev.data.access_token, ev.data.spreadsheetId, ev.data.quizfile, ev.data.quizSettings, ev.data.decryptionKey);\n    } else if (ev.data.type == \"save\") {\n        save(ev.data.userAnswers);\n    } else if (ev.data.type == \"next\") {\n        nextQuestion();\n    }\n})","export class Debouncer {\n    private abort: () => void;\n    constructor() {\n    }\n\n    private timeout(ms: number): Promise<void> {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, ms);\n        });\n    }\n\n    private aborter() {\n        let status = {\n            aborted: false,\n            promise: <Promise<void>>null\n        };\n        let promise = new Promise<void>((resolve, reject) => {\n            this.abort = () => {\n                status.aborted = false;\n                reject();\n            };\n        });\n        status.promise = promise;\n        return status;\n    }\n\n    async trigger(ms: number): Promise<void> {\n        if (this.abort) {\n            this.abort();\n        }\n        let status = this.aborter();\n        try {\n            await Promise.race([this.timeout(ms), status.promise]);\n        }\n        catch {\n            throw new Error(\"aborted\");\n        }\n    }\n}\n"],"names":["currentQuiz","answeredQuestions","currentAccessToken","currentSheetId","currentQuizId","repeat","state","loading","question","needKey","done","decryptFailed","reveal","unsaved","saveerror","async","stateChange","c","self","postMessage","nextQuestion","shift","s","length","getQuizProgress","access_token","spreadsheetId","quizfile","res","fetch","encodeURIComponent","headers","status","method","body","JSON","stringify","data","json","map","Map","values","i","correct","parseInt","total","isNaN","set","getQuiz","decryptionKey","quiz","blob","salt","Uint8Array","arrayBuffer","iv","cryptext","encoder","TextEncoder","keyMaterial","crypto","subtle","importKey","encode","key","deriveKey","decrypted","decrypt","name","decoder","TextDecoder","line","decode","split","startsWith","text","answers","id","substr","test","push","replace","err","loadAndDecryptQuiz","debouncer","abort","constructor","timeout","ms","Promise","resolve","setTimeout","aborter","aborted","promise","reject","this","race","Error","lastSync","addEventListener","ev","type","quizSettings","saveKey","find","d","getDecryptionKey","progress","all","q","p","get","majorDimension","array","temporaryValue","randomIndex","currentIndex","Math","floor","random","shuffle","sort","a","b","numberOfQuestions","slice","initialize","userAnswers","iscorrect","idx","some","v","trigger","max","Date","proc","Array","from","updates","q2","valueInputOption","range","ok","saverror","save"],"sourceRoot":""}